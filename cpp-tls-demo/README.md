# C++ TLS Demo

This project demonstrates how to build a minimal, end-to-end TLS-secured client and server in C++ using OpenSSL. It mirrors the
kind of systems-level prototyping work that might be required when bringing a new service online and needing encrypted transport
from day one.

## Project Layout

```
cpp-tls-demo/
├── CMakeLists.txt
├── README.md
├── certs/
├── include/
│   ├── tls_client.h
│   └── tls_server.h
├── scripts/
│   ├── build.sh
│   ├── demo.sh
│   ├── generate_certs.sh
│   ├── run_client.sh
│   └── run_server.sh
└── src/
    ├── tls_client.cpp
    └── tls_server.cpp
```

The `build/` directory is created by CMake on demand, while development certificates live in `certs/` and are generated by the
provided script.

## Phase-by-Phase Walkthrough

The sections below document what was completed in each phase of the project plan.

### Phase 1 — Environment Setup
- Toolchain requirements: `g++`, `cmake`, `make`, and `libssl-dev`.
- Repository bootstrapping: created the directory structure and a `.gitignore` that keeps build artifacts and generated secrets
  out of version control.
- Added CMake build configuration for two executables (`server` and `client`) that both link against OpenSSL.

### Phase 2 — Generate Self-Signed Certificates
- Added `scripts/generate_certs.sh`, which automates creating a development certificate authority and signing a server
  certificate for `localhost`.
- Certificates are written to the `certs/` directory and are intentionally ignored by Git.

### Phase 3 — Implement TLS Server
- `include/tls_server.h` declares a `TLSServer` class that manages OpenSSL initialization and socket lifetime.
- `src/tls_server.cpp` implements a synchronous server listening on port `5555`. It performs a TLS handshake, prints out useful
  diagnostics, and exchanges a single message with the client before shutting down.

### Phase 4 — Implement TLS Client
- `include/tls_client.h` declares a matching `TLSClient` class that connects to the TLS server.
- `src/tls_client.cpp` implements certificate verification, prints the subject of the server certificate, and sends/receives a
  demo payload.

### Phase 5 — Build and Run
- `scripts/build.sh` wraps the CMake build steps.
- `scripts/run_server.sh` and `scripts/run_client.sh` ensure certificates exist, build the binaries if needed, and then launch
  the respective executable.
- `scripts/demo.sh` starts the server in the background, runs the client, and surfaces the client exit code for convenience.

### Phase 6 — Enhancements (Ideas)
Future improvements you can explore include:
- Mutual TLS by issuing a client certificate and calling `SSL_CTX_use_certificate_file`/`SSL_CTX_use_PrivateKey_file` on the
  client side.
- Transitioning to an asynchronous design using `boost::asio` for concurrent clients.
- Emitting structured logs with `spdlog` or similar for easier observability.
- Integrating tooling such as `valgrind` or `perf` to profile TLS handshake and data path performance.

## Building

```bash
cd cpp-tls-demo
./scripts/build.sh
```

CMake places compiled binaries inside `build/bin/`.

## Generating Certificates

The demo requires certificates before you run the server or client. Generate them once with:

```bash
./scripts/generate_certs.sh
```

The script creates both a certificate authority (`ca.crt`) and a server certificate (`server.crt`). The client trusts the CA
certificate, so certificate verification succeeds even though everything is self-hosted.

## Running the Demo

In two terminals:

```bash
# Terminal 1
cd cpp-tls-demo
./scripts/run_server.sh
```

```bash
# Terminal 2
cd cpp-tls-demo
./scripts/run_client.sh
```

Or run everything from one terminal with:

```bash
cd cpp-tls-demo
./scripts/demo.sh
```

You should see the client send a greeting and the server respond, with both sides printing TLS handshake details to stdout.

## Cleaning Up

Simply delete the `build/` and `certs/` directories to remove compiled artifacts and generated credentials:

```bash
rm -rf build certs
```

Regenerate certificates as needed using the script above.

## Notes

- The sample uses blocking sockets and handles one connection at a time to keep the focus on TLS primitives.
- OpenSSL initialization code includes compatibility paths for OpenSSL 1.1 as well as modern releases.
- For production code, prefer using secure storage for private keys and handle errors with structured logging.
